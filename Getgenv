getgenv().JumperConfig = getgenv().JumperConfig or {
    AutoBlock = false,
    AutoBlockStart = 0.08,
    AutoBlockEnd = 0.28,
    AutoBlockRange = 20,
    AutoBlockDash = false,
    AutoBlockDashStart = 0.04,
    AutoBlockDashEnd = 0.22,
    AutoPunish = false,
    AutoPunishRange = 20,
    AutoPunishDelay = 0.8,
    AutoPunishHits = 4,
    AutoPunishHitDelay = 0.04,
    HoldUntilAnimEnds = false,
    AnimEarlyRelease = 0.15,
    AntiM1 = false,
    AutoLearn = false,
    LookAt = false,
    LookAtSmoothness = 0.15,
    Invisibility = false,
    ShowOrbit = false,
    OrbitColor = Color3.fromRGB(0, 255, 0),
    OrbitTransparency = 0.8,
    SaveCurrentConfig = false,
    ConfigName = "default",
    LoadConfig = ""
}

game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "Jumper",
    Text = "getgenv loaded",
    Duration = 3
})

local cfg = getgenv().JumperConfig

local HttpService = game:GetService("HttpService")

local function saveConfig()
    if not cfg.SaveCurrentConfig then return end
    if cfg.ConfigName == "" then
        warn("Config name cannot be empty")
        return
    end
    
    local configData = {}
    for key, value in pairs(cfg) do
        if key ~= "SaveCurrentConfig" and key ~= "LoadConfig" and key ~= "ConfigName" then
            if typeof(value) == "Color3" then
                configData[key] = {value.R, value.G, value.B}
            else
                configData[key] = value
            end
        end
    end
    
    local fileName = cfg.ConfigName .. ".cfg"
    local success, err = pcall(function()
        if not isfolder("JumperConfigs") then
            makefolder("JumperConfigs")
        end
        if isfile("JumperConfigs/" .. fileName) then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Jumper Config",
                Text = "Config already exists!",
                Duration = 3
            })
            return
        end
        writefile("JumperConfigs/" .. fileName, HttpService:JSONEncode(configData))
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Jumper Config",
            Text = "Config saved: " .. cfg.ConfigName,
            Duration = 3
        })
    end)
    
    if not success then
        warn("Failed to save config: " .. tostring(err))
    end
    
    cfg.SaveCurrentConfig = false
end

local function loadConfig()
    if cfg.LoadConfig == "" then return end
    
    local fileName = cfg.LoadConfig .. ".cfg"
    local success, err = pcall(function()
        if not isfile("JumperConfigs/" .. fileName) then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Jumper Config",
                Text = "Config not found!",
                Duration = 3
            })
            return
        end
        
        local configData = HttpService:JSONDecode(readfile("JumperConfigs/" .. fileName))
        for key, value in pairs(configData) do
            if key == "OrbitColor" and type(value) == "table" then
                cfg[key] = Color3.new(value[1], value[2], value[3])
            else
                cfg[key] = value
            end
        end
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Jumper Config",
            Text = "Config loaded: " .. cfg.LoadConfig,
            Duration = 3
        })
    end)
    
    if not success then
        warn("Failed to load config: " .. tostring(err))
    end
    
    cfg.LoadConfig = ""
end

if cfg.LoadConfig ~= "" then
    loadConfig()
end

task.spawn(function()
    while true do
        if cfg.SaveCurrentConfig then
            saveConfig()
        end
        task.wait(0.5)
    end
end)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Stats = game:GetService("Stats")
local LocalPlayer = Players.LocalPlayer
local CombatRemote = LocalPlayer:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("AttackInput")
local AnimFolder = ReplicatedStorage:WaitForChild("Animations"):WaitForChild("Attacks")

local M1Anims = {}
local isBlocking = false
local AbilityAnims = {}
local DashAnims = {}
local IgnoredAnims = {
    ["rbxassetid://83555998356899"] = true
}
local LearnedTimings = {}

local ignoredAnimPaths = {
    "Evil Spirit",
    "Reset",
    "Pose"
}

local function isIgnoredAnim(anim)
    for _, ignoredName in ipairs(ignoredAnimPaths) do
        if anim:GetFullName():find(ignoredName) then
            return true
        end
    end
    return false
end

for _, folder in ipairs(AnimFolder:GetChildren()) do
    if folder.Name ~= "Backdash" and folder.Name ~= "Sidedash" and folder.Name ~= "Block" and folder.Name ~= "Idle" and folder.Name ~= "Global" then
        for _, anim in ipairs(folder:GetDescendants()) do
            if anim:IsA("Animation") and anim.Name ~= "Idle" and not isIgnoredAnim(anim) then
                AbilityAnims[anim.AnimationId] = true
            end
        end
    end
end

for _, folder in ipairs(AnimFolder:GetChildren()) do
    if folder:IsA("Folder") and folder.Name ~= "Block" and folder.Name ~= "Idle" and folder.Name ~= "Global" then
        for _, subfolder in ipairs(folder:GetChildren()) do
            if subfolder:IsA("Folder") and subfolder.Name ~= "Back" and subfolder.Name ~= "Left" and subfolder.Name ~= "Right" and subfolder.Name ~= "Finisher" and subfolder.Name ~= "Idle" then
                for _, anim in ipairs(subfolder:GetDescendants()) do
                    if anim:IsA("Animation") and anim.Name ~= "Idle" and not isIgnoredAnim(anim) then
                        DashAnims[anim.AnimationId] = true
                    end
                end
            end
        end
    end
end

local M1Folder = AnimFolder:WaitForChild("Global"):WaitForChild("M1")
for _, anim in ipairs(M1Folder:GetDescendants()) do
    if anim:IsA("Animation") and anim.Name ~= "Idle" and not IgnoredAnims[anim.AnimationId] then
        M1Anims[anim.AnimationId] = true
    end
end

local function stopBlocking()
    if isBlocking then
        CombatRemote:FireServer("Block", false)
        isBlocking = false
    end
end

local function findNearestM1Attacker()
    local char = LocalPlayer.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closestDist = cfg.AutoBlockRange
    local target = nil
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local enemyChar = player.Character
            local enemyHRP = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local dist = (hrp.Position - enemyHRP.Position).Magnitude
                if dist < closestDist then
                    local hum = enemyChar:FindFirstChildOfClass("Humanoid")
                    if hum then
                        for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                            if M1Anims[track.Animation.AnimationId] then
                                target = player
                                closestDist = dist
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    return target
end

local function findNearestDashAttacker()
    local char = LocalPlayer.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closestDist = cfg.AutoBlockRange
    local target = nil
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local enemyChar = player.Character
            local enemyHRP = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local dist = (hrp.Position - enemyHRP.Position).Magnitude
                if dist < closestDist then
                    local hum = enemyChar:FindFirstChildOfClass("Humanoid")
                    if hum then
                        for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                            if DashAnims[track.Animation.AnimationId] then
                                target = player
                                closestDist = dist
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    return target
end

local function findNearestAbilityUser()
    local char = LocalPlayer.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closestDist = cfg.AutoPunishRange
    local target = nil
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local enemyChar = player.Character
            local enemyHRP = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local dist = (hrp.Position - enemyHRP.Position).Magnitude
                if dist < closestDist then
                    local hum = enemyChar:FindFirstChildOfClass("Humanoid")
                    if hum then
                        for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                            if AbilityAnims[track.Animation.AnimationId] then
                                target = player
                                closestDist = dist
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    return target
end

local isPunishing = false
local dashBlocking = false
local currentPunishTrack = nil
local currentPunishTarget = nil

local function updateLearning(playerId, animId, blockSuccess)
    if not cfg.AutoLearn then return end
    if not LearnedTimings[playerId] then
        LearnedTimings[playerId] = {}
    end
    if not LearnedTimings[playerId][animId] then
        LearnedTimings[playerId][animId] = {
            successes = 0,
            failures = 0,
            avgDelay = cfg.AutoBlockStart
        }
    end
    local data = LearnedTimings[playerId][animId]
    if blockSuccess then
        data.successes = data.successes + 1
        data.avgDelay = math.max(0.05, data.avgDelay - 0.005)
    else
        data.failures = data.failures + 1
        data.avgDelay = math.min(0.15, data.avgDelay + 0.01)
    end
end

local function getLearnedDelay(playerId, animId, defaultDelay)
    if not cfg.AutoLearn then return defaultDelay end
    if LearnedTimings[playerId] and LearnedTimings[playerId][animId] then
        return LearnedTimings[playerId][animId].avgDelay
    end
    return defaultDelay
end

RunService.Heartbeat:Connect(function()
    if cfg.AutoBlock then
        local m1Target = findNearestM1Attacker()
        if m1Target and not isBlocking then
            isBlocking = true
            local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 2000
            local currentAnim = nil
            local enemyHum = m1Target.Character and m1Target.Character:FindFirstChildOfClass("Humanoid")
            if enemyHum then
                for _, track in ipairs(enemyHum:GetPlayingAnimationTracks()) do
                    if M1Anims[track.Animation.AnimationId] then
                        currentAnim = track.Animation.AnimationId
                        break
                    end
                end
            end
            local startDelay = getLearnedDelay(m1Target.UserId, currentAnim, cfg.AutoBlockStart) + ping
            task.delay(startDelay, function()
                if isBlocking then
                    CombatRemote:FireServer("Block", true)
                    local blockStart = tick()
                    task.delay(cfg.AutoBlockEnd, function()
                        if isBlocking then
                            CombatRemote:FireServer("Block", false)
                            local blockDuration = tick() - blockStart
                            if currentAnim then
                                updateLearning(m1Target.UserId, currentAnim, blockDuration >= 0.1)
                            end
                            isBlocking = false
                        end
                    end)
                end
            end)
        end
        
        if cfg.AutoBlockDash then
            local dashTarget = findNearestDashAttacker()
            if dashTarget and not dashBlocking then
                dashBlocking = true
                local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 2000
                local startDelay = cfg.AutoBlockDashStart + ping
                task.delay(startDelay, function()
                    if dashBlocking then
                        CombatRemote:FireServer("Block", true)
                        task.delay(cfg.AutoBlockDashEnd, function()
                            if dashBlocking then
                                CombatRemote:FireServer("Block", false)
                                dashBlocking = false
                            end
                        end)
                    end
                end)
            end
        end
    else
        stopBlocking()
    end
    
    if cfg.AutoPunish then
        local abilityTarget = findNearestAbilityUser()
        if abilityTarget and not isPunishing and not isBlocking and not dashBlocking then
            local enemyChar = abilityTarget.Character
            local hum = enemyChar and enemyChar:FindFirstChildOfClass("Humanoid")
            if hum then
                for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                    if AbilityAnims[track.Animation.AnimationId] then
                        isPunishing = true
                        currentPunishTrack = track
                        currentPunishTarget = abilityTarget
                        
                        if cfg.HoldUntilAnimEnds then
                            task.spawn(function()
                                CombatRemote:FireServer("Block", true)
                                while isPunishing and currentPunishTrack and currentPunishTrack.IsPlaying and currentPunishTarget == abilityTarget do
                                    task.wait()
                                end
                                CombatRemote:FireServer("Block", false)
                                if isPunishing and currentPunishTarget == abilityTarget then
                                    for i = 1, cfg.AutoPunishHits do
                                        CombatRemote:FireServer("M1", true)
                                        task.wait(cfg.AutoPunishHitDelay)
                                    end
                                    CombatRemote:FireServer("M1", false)
                                    task.wait(cfg.AutoPunishDelay)
                                end
                                isPunishing = false
                                currentPunishTrack = nil
                                currentPunishTarget = nil
                            end)
                        else
                            task.spawn(function()
                                task.wait(cfg.AnimEarlyRelease)
                                if isPunishing and currentPunishTarget == abilityTarget then
                                    for i = 1, cfg.AutoPunishHits do
                                        CombatRemote:FireServer("M1", true)
                                        task.wait(cfg.AutoPunishHitDelay)
                                    end
                                    CombatRemote:FireServer("M1", false)
                                    task.wait(cfg.AutoPunishDelay)
                                end
                                isPunishing = false
                                currentPunishTrack = nil
                                currentPunishTarget = nil
                            end)
                        end
                        break
                    end
                end
            end
        elseif isPunishing and currentPunishTrack and not currentPunishTrack.IsPlaying then
            isPunishing = false
            currentPunishTrack = nil
            currentPunishTarget = nil
        end
    else
        if isPunishing then
            isPunishing = false
            currentPunishTrack = nil
            currentPunishTarget = nil
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if cfg.LookAt then
        local target = findNearestM1Attacker()
        if target and target.Character then
            local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
            local myChar = LocalPlayer.Character
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            
            if targetHRP and myHRP then
                local targetPos = targetHRP.Position
                local currentPos = myHRP.Position
                local lookPos = Vector3.new(targetPos.X, currentPos.Y, targetPos.Z)
                local targetCFrame = CFrame.new(currentPos, lookPos)
                myHRP.CFrame = myHRP.CFrame:Lerp(targetCFrame, cfg.LookAtSmoothness)
            end
        end
    end
end)

RunService.Heartbeat:Connect(function()
    if cfg.AntiM1 then
        local statesHolder = LocalPlayer.PlayerGui:FindFirstChild("StatesHolder")
        if statesHolder then
            local states = statesHolder:FindFirstChild("States")
            if states then
                states:SetAttribute("Stunned", false)
            end
        end
    end
end)

local orbitPart = nil

local function createOrbit()
    if orbitPart then
        orbitPart:Destroy()
        orbitPart = nil
    end
    
    if not cfg.ShowOrbit then return end
    
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    orbitPart = Instance.new("Part")
    orbitPart.Name = "OrbitIndicator"
    orbitPart.Shape = Enum.PartType.Ball
    orbitPart.Material = Enum.Material.ForceField
    orbitPart.Size = Vector3.new(cfg.AutoBlockRange * 2, cfg.AutoBlockRange * 2, cfg.AutoBlockRange * 2)
    orbitPart.Color = cfg.OrbitColor
    orbitPart.Transparency = cfg.OrbitTransparency
    orbitPart.CanCollide = false
    orbitPart.Anchored = true
    orbitPart.CastShadow = false
    orbitPart.CFrame = hrp.CFrame
    orbitPart.Parent = workspace
end

RunService.RenderStepped:Connect(function()
    if cfg.ShowOrbit then
        local char = LocalPlayer.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                if not orbitPart or not orbitPart.Parent then
                    createOrbit()
                end
                if orbitPart then
                    orbitPart.CFrame = hrp.CFrame
                    orbitPart.Size = Vector3.new(cfg.AutoBlockRange * 2, cfg.AutoBlockRange * 2, cfg.AutoBlockRange * 2)
                    orbitPart.Color = cfg.OrbitColor
                    orbitPart.Transparency = cfg.OrbitTransparency
                end
            end
        end
    else
        if orbitPart then
            orbitPart:Destroy()
            orbitPart = nil
        end
    end
end)

local connections = {}
local currentAnim = nil
local bodyParts = {
    "Head",
    "Torso",
    "Left Arm",
    "Right Arm",
    "Left Leg",
    "Right Leg"
}

local function setTransparency(transparency, character)
    for _, partName in ipairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            part.Transparency = transparency
        end
    end
end

local function cleanup()
    for _, connection in pairs(connections) do
        if connection then
            connection:Disconnect()
        end
    end
    connections = {}
    if currentAnim and currentAnim.IsPlaying then
        currentAnim:Stop()
    end
end

local function setupInvisibility(character)
    cleanup()
    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    local animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://83555998356899"
    currentAnim = animator:LoadAnimation(animation)
    currentAnim.Priority = Enum.AnimationPriority.Action4
    
    if cfg.Invisibility then
        setTransparency(0.5, character)
        table.insert(connections, RunService.Heartbeat:Connect(function()
            if not currentAnim.IsPlaying then
                currentAnim:Play()
            end
            currentAnim:AdjustSpeed(0)
            currentAnim.TimePosition = 10
        end))
        table.insert(connections, RunService.RenderStepped:Connect(function()
            if currentAnim.IsPlaying then
                currentAnim:Stop()
            end
        end))
    else
        setTransparency(0, character)
    end
end

LocalPlayer.CharacterAdded:Connect(function(character)
    character:WaitForChild("HumanoidRootPart")
    cleanup()
    setupInvisibility(character)
    if orbitPart then
        orbitPart:Destroy()
        orbitPart = nil
    end
    createOrbit()
end)

if LocalPlayer.Character then
    setupInvisibility(LocalPlayer.Character)
end
