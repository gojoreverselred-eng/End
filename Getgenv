getgenv().JumperConfig = getgenv().JumperConfig or {
    AutoBlock = false,
    AutoBlockStart = 0.08,
    AutoBlockEnd = 0.28,
    AutoBlockRange = 20,
    AutoBlockDash = false,
    AutoBlockDashStart = 0.04,
    AutoBlockDashEnd = 0.22,
    AutoPunish = false,
    AutoPunishRange = 20,
    AutoPunishDelay = 0.8,
    AutoPunishHits = 4,
    AutoPunishHitDelay = 0.04,
    HoldUntilAnimEnds = false,
    AutoPunishEarlyRelease = 0.03,
    AntiM1 = false,
    AntiM1Range = 20,
    LookAt = false,
    LookAtSmoothness = 0.15,
    Invisibility = false
}

game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "Jumper",
    Text = "Script loaded",
    Duration = 3
})

local cfg = getgenv().JumperConfig
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Stats = game:GetService("Stats")
local LocalPlayer = Players.LocalPlayer
local CombatRemote = LocalPlayer:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("AttackInput")
local AnimFolder = ReplicatedStorage:WaitForChild("Animations"):WaitForChild("Attacks")

local M1Anims = {}
local isBlocking = false
local AbilityAnims = {}
local DashAnims = {}

for _, folder in ipairs(AnimFolder:GetChildren()) do
    if folder.Name ~= "Backdash" and folder.Name ~= "Sidedash" and folder.Name ~= "Block" and folder.Name ~= "Idle" then
        for _, anim in ipairs(folder:GetDescendants()) do
            if anim:IsA("Animation") and anim.Name ~= "Idle" then
                AbilityAnims[anim.AnimationId] = true
            end
        end
    end
end

for _, folder in ipairs(AnimFolder:GetChildren()) do
    if folder:IsA("Folder") and folder.Name ~= "Block" and folder.Name ~= "Idle" then
        for _, subfolder in ipairs(folder:GetChildren()) do
            if subfolder:IsA("Folder") and subfolder.Name ~= "Back" and subfolder.Name ~= "Left" and subfolder.Name ~= "Right" and subfolder.Name ~= "Finisher" and subfolder.Name ~= "Idle" then
                for _, anim in ipairs(subfolder:GetDescendants()) do
                    if anim:IsA("Animation") and anim.Name ~= "Idle" then
                        DashAnims[anim.AnimationId] = true
                    end
                end
            end
        end
    end
end

local M1Folder = AnimFolder:WaitForChild("Global"):WaitForChild("M1")
for _, anim in ipairs(M1Folder:GetDescendants()) do
    if anim:IsA("Animation") and anim.Name ~= "Idle" then
        M1Anims[anim.AnimationId] = true
    end
end

local function stopBlocking()
    if isBlocking then
        CombatRemote:FireServer("Block", false)
        isBlocking = false
    end
end

local function findNearestM1Attacker()
    local char = LocalPlayer.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closestDist = cfg.AutoBlockRange
    local target = nil
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local enemyChar = player.Character
            local enemyHRP = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local dist = (hrp.Position - enemyHRP.Position).Magnitude
                if dist < closestDist then
                    local hum = enemyChar:FindFirstChildOfClass("Humanoid")
                    if hum then
                        for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                            if M1Anims[track.Animation.AnimationId] then
                                target = player
                                closestDist = dist
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    return target
end

local function findNearestDashAttacker()
    local char = LocalPlayer.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closestDist = cfg.AutoBlockRange
    local target = nil
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local enemyChar = player.Character
            local enemyHRP = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local dist = (hrp.Position - enemyHRP.Position).Magnitude
                if dist < closestDist then
                    local hum = enemyChar:FindFirstChildOfClass("Humanoid")
                    if hum then
                        for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                            if DashAnims[track.Animation.AnimationId] then
                                target = player
                                closestDist = dist
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    return target
end

local function findNearestAbilityUser()
    local char = LocalPlayer.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closestDist = cfg.AutoPunishRange
    local target = nil
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local enemyChar = player.Character
            local enemyHRP = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local dist = (hrp.Position - enemyHRP.Position).Magnitude
                if dist < closestDist then
                    local hum = enemyChar:FindFirstChildOfClass("Humanoid")
                    if hum then
                        for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                            if AbilityAnims[track.Animation.AnimationId] then
                                target = player
                                closestDist = dist
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    return target
end

local function findNearestAntiM1Target()
    local char = LocalPlayer.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local closestDist = cfg.AntiM1Range
    local target = nil
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local enemyChar = player.Character
            local enemyHRP = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local dist = (hrp.Position - enemyHRP.Position).Magnitude
                if dist < closestDist then
                    local hum = enemyChar:FindFirstChildOfClass("Humanoid")
                    if hum then
                        for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                            if M1Anims[track.Animation.AnimationId] then
                                target = player
                                closestDist = dist
                                break
                            end
                        end
                    end
                end
            end
        end
    end
    return target
end

local isPunishing = false
local dashBlocking = false
local currentPunishTrack = nil
local currentPunishTarget = nil

RunService.Heartbeat:Connect(function()
    if cfg.AutoBlock then
        local m1Target = findNearestM1Attacker()
        if m1Target and not isBlocking then
            isBlocking = true
            local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 2000
            local startDelay = cfg.AutoBlockStart + ping
            task.delay(startDelay, function()
                if isBlocking then
                    CombatRemote:FireServer("Block", true)
                    task.delay(cfg.AutoBlockEnd, function()
                        if isBlocking then
                            CombatRemote:FireServer("Block", false)
                            isBlocking = false
                        end
                    end)
                end
            end)
        end
        
        if cfg.AutoBlockDash then
            local dashTarget = findNearestDashAttacker()
            if dashTarget and not dashBlocking then
                dashBlocking = true
                local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 2000
                local startDelay = cfg.AutoBlockDashStart + ping
                task.delay(startDelay, function()
                    if dashBlocking then
                        CombatRemote:FireServer("Block", true)
                        task.delay(cfg.AutoBlockDashEnd, function()
                            if dashBlocking then
                                CombatRemote:FireServer("Block", false)
                                dashBlocking = false
                            end
                        end)
                    end
                end)
            end
        end
    else
        stopBlocking()
    end
    
    if cfg.AutoPunish then
        local abilityTarget = findNearestAbilityUser()
        if abilityTarget and not isPunishing and not isBlocking and not dashBlocking then
            local enemyChar = abilityTarget.Character
            local hum = enemyChar and enemyChar:FindFirstChildOfClass("Humanoid")
            if hum then
                for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                    if AbilityAnims[track.Animation.AnimationId] then
                        isPunishing = true
                        currentPunishTrack = track
                        currentPunishTarget = abilityTarget
                        
                        if cfg.HoldUntilAnimEnds then
                            task.spawn(function()
                                CombatRemote:FireServer("Block", true)
                                while isPunishing and currentPunishTrack and currentPunishTrack.IsPlaying and currentPunishTarget == abilityTarget do
                                    task.wait()
                                end
                                CombatRemote:FireServer("Block", false)
                                if isPunishing and currentPunishTarget == abilityTarget then
                                    for i = 1, cfg.AutoPunishHits do
                                        CombatRemote:FireServer("M1", true)
                                        task.wait(cfg.AutoPunishHitDelay)
                                    end
                                    CombatRemote:FireServer("M1", false)
                                    task.wait(cfg.AutoPunishDelay)
                                end
                                isPunishing = false
                                currentPunishTrack = nil
                                currentPunishTarget = nil
                            end)
                        else
                            task.spawn(function()
                                task.wait(cfg.AutoPunishEarlyRelease)
                                if isPunishing and currentPunishTarget == abilityTarget then
                                    for i = 1, cfg.AutoPunishHits do
                                        CombatRemote:FireServer("M1", true)
                                        task.wait(cfg.AutoPunishHitDelay)
                                    end
                                    CombatRemote:FireServer("M1", false)
                                    task.wait(cfg.AutoPunishDelay)
                                end
                                isPunishing = false
                                currentPunishTrack = nil
                                currentPunishTarget = nil
                            end)
                        end
                        break
                    end
                end
            end
        elseif isPunishing and currentPunishTrack and not currentPunishTrack.IsPlaying then
            isPunishing = false
            currentPunishTrack = nil
            currentPunishTarget = nil
        end
    else
        if isPunishing then
            isPunishing = false
            currentPunishTrack = nil
            currentPunishTarget = nil
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if cfg.LookAt then
        local target = findNearestM1Attacker()
        if target and target.Character then
            local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
            local myChar = LocalPlayer.Character
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            
            if targetHRP and myHRP then
                local targetPos = targetHRP.Position
                local currentPos = myHRP.Position
                local lookPos = Vector3.new(targetPos.X, currentPos.Y, targetPos.Z)
                local targetCFrame = CFrame.new(currentPos, lookPos)
                myHRP.CFrame = myHRP.CFrame:Lerp(targetCFrame, cfg.LookAtSmoothness)
            end
        end
    end
end)

RunService.Heartbeat:Connect(function()
    if cfg.AntiM1 then
        local antiM1Target = findNearestAntiM1Target()
        if antiM1Target then
            local statesHolder = LocalPlayer.PlayerGui.StatesHolder.States
            statesHolder:SetAttribute("Stunned", false)
        end
    end
end)

local connections = {}
local currentAnim = nil
local bodyParts = {
    "Head",
    "Torso",
    "Left Arm",
    "Right Arm",
    "Left Leg",
    "Right Leg"
}

local function setTransparency(transparency, character)
    for _, partName in ipairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            part.Transparency = transparency
        end
    end
end

local function cleanup()
    for _, connection in pairs(connections) do
        if connection then
            connection:Disconnect()
        end
    end
    connections = {}
    if currentAnim and currentAnim.IsPlaying then
        currentAnim:Stop()
    end
end

local function setupInvisibility(character)
    cleanup()
    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    local animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://83555998356899"
    currentAnim = animator:LoadAnimation(animation)
    currentAnim.Priority = Enum.AnimationPriority.Action4
    
    if cfg.Invisibility then
        setTransparency(0.5, character)
        table.insert(connections, RunService.Heartbeat:Connect(function()
            if not currentAnim.IsPlaying then
                currentAnim:Play()
            end
            currentAnim:AdjustSpeed(0)
            currentAnim.TimePosition = 10
        end))
        table.insert(connections, RunService.RenderStepped:Connect(function()
            if currentAnim.IsPlaying then
                currentAnim:Stop()
            end
        end))
    else
        setTransparency(0, character)
    end
end

LocalPlayer.CharacterAdded:Connect(function(character)
    character:WaitForChild("HumanoidRootPart")
    cleanup()
    setupInvisibility(character)
end)

if LocalPlayer.Character then
    setupInvisibility(LocalPlayer.Character)
end
